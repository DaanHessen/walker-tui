package main

// Simple enums generator: reads internal/engine/enums.yml and regenerates enums.go with Parse/String helpers.

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

type spec struct {
	Traits     []string `yaml:"traits"`
	Skills     []string `yaml:"skills"`
	Conditions []string `yaml:"conditions"`
	Meters     []string `yaml:"meters"`
	Location   []string `yaml:"location_types"`
	Seasons    []string `yaml:"seasons"`
	Weather    []string `yaml:"weather"`
	TempBands  []string `yaml:"temp_bands"`
	RiskLevels []string `yaml:"risk_levels"`
	GroupTypes []string `yaml:"group_types"`
}

func main() {
	out := flag.String("o", "internal/engine/enums.go", "output file")
	in := flag.String("i", "internal/engine/enums.yml", "input YAML")
	flag.Parse()
	b, err := ioutil.ReadFile(*in)
	if err != nil {
		log.Fatal(err)
	}
	s := spec{}
	if err := yaml.Unmarshal(b, &s); err != nil {
		log.Fatal(err)
	}
	var buf bytes.Buffer
	w := func(f string, a ...any) { fmt.Fprintf(&buf, f, a...) }
	w("package engine\n\n// Code generated by enumsgen; DO NOT EDIT.\n\n")
	writeEnum(&buf, "Trait", s.Traits)
	writeEnum(&buf, "Skill", s.Skills)
	writeEnum(&buf, "Condition", s.Conditions)
	writeEnum(&buf, "Meter", s.Meters)
	writeEnum(&buf, "LocationType", s.Location)
	writeAliases(&buf, "Location", "LocationType", s.Location)
	writeEnum(&buf, "Season", s.Seasons)
	writeEnum(&buf, "Weather", s.Weather)
	writeEnum(&buf, "TempBand", s.TempBands)
	writeAliases(&buf, "Temp", "TempBand", s.TempBands)
	writeEnum(&buf, "RiskLevel", s.RiskLevels)
	writeAliases(&buf, "Risk", "RiskLevel", s.RiskLevels)
	writeEnum(&buf, "GroupType", s.GroupTypes)
	writeAliases(&buf, "Group", "GroupType", s.GroupTypes)
	w(`// Generic helpers
func contains[T ~string](list []T, v T) bool { for _, x := range list { if x==v { return true } }; return false }
`)
	w("\n")
	// Validate + List + Parse
	sections := []struct {
		t    string
		list []string
	}{
		{"Trait", s.Traits}, {"Skill", s.Skills}, {"Condition", s.Conditions}, {"Meter", s.Meters}, {"LocationType", s.Location}, {"Season", s.Seasons}, {"Weather", s.Weather}, {"TempBand", s.TempBands}, {"RiskLevel", s.RiskLevels}, {"GroupType", s.GroupTypes},
	}
	for _, sec := range sections {
		capName := sec.t
		w("func (e %s) Validate() bool { return contains(All%ss, e) }\n", capName, capName)
		w("func (e %s) String() string { return string(e) }\n", capName)
		w("func Parse%s(s string) (%s, bool) { for _, v := range All%ss { if string(v)==s { return v, true } }; return %s(\"\"), false }\n", capName, capName, capName, capName)
		w("func List%ss() []%s { return append([]%s{}, All%ss...) }\n\n", capName, capName, capName, capName)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if err := os.MkdirAll(filepath.Dir(*out), 0o755); err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile(*out, formatted, 0o644); err != nil {
		log.Fatal(err)
	}
}

func writeEnum(buf *bytes.Buffer, typeName string, values []string) {
	sort.Strings(values)
	fmt.Fprintf(buf, "type %s string\n\nconst (\n", typeName)
	for _, v := range values {
		constName := constIdent(typeName, v)
		fmt.Fprintf(buf, "\t%s %s = \"%s\"\n", constName, typeName, v)
	}
	fmt.Fprintf(buf, ")\n\nvar All%ss = []%s{", typeName, typeName)
	for i, v := range values {
		if i > 0 {
			buf.WriteString(",")
		}
		fmt.Fprintf(buf, "%s", constIdent(typeName, v))
	}
	buf.WriteString("}\n\n")
}

func writeAliases(buf *bytes.Buffer, aliasPrefix, targetType string, values []string) {
	if len(values) == 0 {
		return
	}
	sort.Strings(values)
	fmt.Fprintf(buf, "const (\n")
	for _, v := range values {
		fmt.Fprintf(buf, "\t%s = %s\n", constIdent(aliasPrefix, v), constIdent(targetType, v))
	}
	fmt.Fprintf(buf, ")\n\n")
}

func constIdent(prefix, raw string) string {
	parts := strings.FieldsFunc(raw, func(r rune) bool { return r == '_' || r == '-' })
	for i, p := range parts {
		parts[i] = strings.Title(p)
	}
	return prefix + strings.Join(parts, "")
}
